# Stubs for astroid.scoped_nodes (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from astroid import mixins, node_classes
from astroid.nodes import Decorators
from typing import Any, Iterator, List, Optional

BUILTINS: Any
ITER_METHODS: Any

def function_to_method(n: Any, klass: Any) -> Any: ...

MANAGER: Any

def builtin_lookup(name: Any) -> Any: ...

class LocalsDictNodeNG(node_classes.LookupMixIn, node_classes.NodeNG):
    locals: Any = ...
    def qname(self) -> Any: ...
    def frame(self) -> Any: ...
    def scope(self) -> Any: ...
    def set_local(self, name: Any, stmt: Any) -> None: ...
    __setitem__: Any = ...
    def add_local_node(self, child_node: Any, name: Optional[Any] = ...) -> None: ...
    def __getitem__(self, item: Any) -> Any: ...
    def __iter__(self) -> Any: ...
    def keys(self) -> Any: ...
    def values(self) -> Any: ...
    def items(self) -> Any: ...
    def __contains__(self, name: Any) -> Any: ...

class Module(LocalsDictNodeNG):
    lineno: int = ...
    file: Any = ...
    file_bytes: Any = ...
    file_encoding: Any = ...
    name: Any = ...
    pure_python: Any = ...
    package: Any = ...
    globals: Any = ...
    future_imports: Any = ...
    special_attributes: Any = ...
    scope_attrs: Any = ...
    doc: Any = ...
    path: Any = ...
    parent: Any = ...
    locals: Any = ...
    body: Any = ...
    def __init__(self, name: Any, doc: Any, file: Any=..., path: Optional[List[str]]=..., package: Any=..., parent: Any=..., pure_python: Any=...) -> None: ...
    def postinit(self, body: Optional[Any] = ...) -> None: ...
    def stream(self) -> Any: ...
    def block_range(self, lineno: Any) -> Any: ...
    def scope_lookup(self, node: Any, name: Any, offset: int = ...) -> Any: ...
    def pytype(self) -> Any: ...
    def display_type(self) -> Any: ...
    def getattr(self, name: Any, context: Optional[Any] = ..., ignore_locals: bool = ...) -> Any: ...
    def igetattr(self, name: Any, context: Optional[Any] = ...) -> Any: ...
    def fully_defined(self) -> Any: ...
    def statement(self) -> Any: ...
    def previous_sibling(self) -> None: ...
    def next_sibling(self) -> None: ...
    def absolute_import_activated(self) -> Any: ...
    def import_module(self, modname: Any, relative_only: bool = ..., level: Optional[Any] = ...) -> Any: ...
    def relative_to_absolute_name(self, modname: Any, level: Any) -> Any: ...
    def wildcard_import_names(self) -> Any: ...
    def public_names(self) -> Any: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class ComprehensionScope(LocalsDictNodeNG):
    def frame(self) -> Any: ...
    scope_lookup: Any = ...

class GeneratorExp(ComprehensionScope):
    elt: Any = ...
    generators: Any = ...
    locals: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, elt: Optional[Any] = ..., generators: Optional[Any] = ...) -> None: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class DictComp(ComprehensionScope):
    key: Any = ...
    value: Any = ...
    generators: Any = ...
    locals: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, key: Optional[Any] = ..., value: Optional[Any] = ..., generators: Optional[Any] = ...) -> None: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class SetComp(ComprehensionScope):
    elt: Any = ...
    generators: Any = ...
    locals: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, elt: Optional[Any] = ..., generators: Optional[Any] = ...) -> None: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class _ListComp(node_classes.NodeNG):
    elt: Any = ...
    generators: Any = ...
    def postinit(self, elt: Optional[Any] = ..., generators: Optional[Any] = ...) -> None: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class ListComp(_ListComp, ComprehensionScope):
    locals: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class Lambda(mixins.FilterStmtsMixin, LocalsDictNodeNG):
    name: str = ...
    is_lambda: bool = ...
    def implicit_parameters(self) -> Any: ...
    @property
    def type(self) -> Any: ...
    locals: Any = ...
    args: Any = ...
    body: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, args: Any, body: Any) -> None: ...
    def pytype(self) -> Any: ...
    def display_type(self) -> Any: ...
    def callable(self) -> Any: ...
    def argnames(self) -> Any: ...
    def infer_call_result(self, caller: Any, context: Optional[Any] = ...) -> Any: ...
    def scope_lookup(self, node: Any, name: Any, offset: int = ...) -> Any: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class FunctionDef(mixins.MultiLineBlockMixin, node_classes.Statement, Lambda):
    returns: Any = ...
    decorators: Any = ...
    special_attributes: Any = ...
    is_function: bool = ...
    type_annotation: Any = ...
    type_comment_args: Any = ...
    type_comment_returns: Any = ...
    name: Any = ...
    doc: Any = ...
    instance_attrs: Any = ...
    def __init__(self, name: Optional[Any] = ..., doc: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    args: Any = ...
    body: Any = ...
    def postinit(self, args: Any, body: Any, decorators: Optional[Any] = ..., returns: Optional[Any] = ..., type_comment_returns: Optional[Any] = ..., type_comment_args: Optional[Any] = ...) -> None: ...
    def extra_decorators(self) -> Any: ...
    def type(self) -> Any: ...
    def fromlineno(self) -> int: ...
    def blockstart_tolineno(self) -> Any: ...
    def block_range(self, lineno: Any) -> Any: ...
    def getattr(self, name: Any, context: Optional[Any] = ...) -> Any: ...
    def igetattr(self, name: Any, context: Optional[Any] = ...) -> Any: ...
    def is_method(self) -> Any: ...
    def decoratornames(self) -> Any: ...
    def is_bound(self) -> Any: ...
    def is_abstract(self, pass_is_abstract: bool = ...) -> Any: ...
    def is_generator(self) -> Any: ...
    def infer_call_result(self, caller: Optional[Any] = ..., context: Optional[Any] = ...) -> None: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...

class AsyncFunctionDef(FunctionDef): ...

def get_wrapping_class(node: Any) -> Any: ...

class ClassDef(mixins.FilterStmtsMixin, LocalsDictNodeNG, node_classes.Statement):
    decorators: Optional[Decorators] = ...
    special_attributes: Any = ...
    hide: bool = ...
    type: Any = ...
    instance_attrs: Any = ...
    locals: Any = ...
    keywords: Any = ...
    bases: Any = ...
    body: Any = ...
    name: Any = ...
    doc: Any = ...
    def __init__(self, name: Optional[Any] = ..., doc: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def implicit_parameters(self) -> Any: ...
    def implicit_locals(self) -> Any: ...
    def postinit(self, bases: Any, body: Any, decorators: Any, newstyle: Optional[Any] = ..., metaclass: Optional[Any] = ..., keywords: Optional[Any] = ...) -> None: ...
    newstyle: Any = ...
    def blockstart_tolineno(self) -> Any: ...
    def block_range(self, lineno: Any) -> Any: ...
    def pytype(self) -> Any: ...
    def display_type(self) -> Any: ...
    def callable(self) -> Any: ...
    def is_subtype_of(self, type_name: Any, context: Optional[Any] = ...) -> Any: ...
    def infer_call_result(self, caller: Any, context: Optional[Any] = ...) -> None: ...
    def scope_lookup(self, node: Any, name: Any, offset: int = ...) -> Any: ...
    @property
    def basenames(self) -> Any: ...
    def ancestors(self, recurs: bool = ..., context: Optional[Any] = ...) -> None: ...
    def local_attr_ancestors(self, name: Any, context: Optional[Any] = ...) -> None: ...
    def instance_attr_ancestors(self, name: Any, context: Optional[Any] = ...) -> None: ...
    def has_base(self, node: Any) -> Any: ...
    def local_attr(self, name: Any, context: Optional[Any] = ...) -> Any: ...
    def instance_attr(self, name: Any, context: Optional[Any] = ...) -> Any: ...
    def instantiate_class(self) -> Any: ...
    def getattr(self, name: Any, context: Optional[Any] = ..., class_context: bool = ...) -> Any: ...
    def igetattr(self, name: Any, context: Optional[Any] = ..., class_context: bool = ...) -> None: ...
    def has_dynamic_getattr(self, context: Optional[Any] = ...) -> Any: ...
    def getitem(self, index: Any, context: Optional[Any] = ...) -> Any: ...
    def methods(self) -> None: ...
    def mymethods(self) -> None: ...
    def implicit_metaclass(self) -> Any: ...
    def declared_metaclass(self, context: Optional[Any] = ...) -> Any: ...
    def metaclass(self, context: Optional[Any] = ...) -> Any: ...
    def has_metaclass_hack(self) -> Any: ...
    def slots(self) -> Any: ...
    def mro(self, context: Any=...) -> List[ClassDef]: ...
    def bool_value(self) -> Any: ...
    def get_children(self) -> Iterator[node_classes.NodeNG]: ...
