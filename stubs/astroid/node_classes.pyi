# Stubs for astroid.node_classes (Python 3)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

import abc
from astroid import bases, mixins
from astroid.scoped_nodes import ClassDef as ClassDef
from typing import Any, Iterator, Optional

BUILTINS: Any
MANAGER: Any

def unpack_infer(stmt: Any, context: Optional[Any] = ...) -> Any: ...
def are_exclusive(stmt1: Any, stmt2: Any, exceptions: Optional[Any] = ...) -> Any: ...

OP_PRECEDENCE: Any

class NodeNG:
    is_statement: bool = ...
    optional_assign: bool = ...
    is_function: bool = ...
    is_lambda: bool = ...
    lineno: Any = ...
    col_offset: Any = ...
    parent: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def infer(self, context: Optional[Any] = ..., **kwargs: Any) -> Any: ...
    def accept(self, visitor: Any) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def last_child(self) -> Any: ...
    def parent_of(self, node: Any) -> Any: ...
    def statement(self) -> Any: ...
    def frame(self) -> Any: ...
    def scope(self) -> Any: ...
    def root(self) -> Any: ...
    def child_sequence(self, child: Any) -> Any: ...
    def locate_child(self, child: Any) -> Any: ...
    def next_sibling(self) -> Any: ...
    def previous_sibling(self) -> Any: ...
    def nearest(self, nodes: Any) -> Any: ...
    def fromlineno(self) -> Any: ...
    def tolineno(self) -> Any: ...
    def block_range(self, lineno: Any) -> Any: ...
    def set_local(self, name: Any, stmt: Any) -> None: ...
    def nodes_of_class(self, klass: Any, skip_klass: Optional[Any] = ...) -> None: ...
    def inferred(self) -> Any: ...
    def instantiate_class(self) -> Any: ...
    def has_base(self, node: Any) -> Any: ...
    def callable(self) -> Any: ...
    def eq(self, value: Any) -> Any: ...
    def as_string(self) -> Any: ...
    def repr_tree(self, ids: bool = ..., include_linenos: bool = ..., ast_state: bool = ..., indent: str = ..., max_depth: int = ..., max_width: int = ...) -> Any: ...
    def bool_value(self) -> Any: ...
    def op_precedence(self) -> Any: ...
    def op_left_associative(self) -> Any: ...

class Statement(NodeNG):
    is_statement: bool = ...
    def next_sibling(self) -> Any: ...
    def previous_sibling(self) -> Any: ...

class _BaseContainer(mixins.ParentAssignTypeMixin, NodeNG, bases.Instance, metaclass=abc.ABCMeta):
    elts: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, elts: Any) -> None: ...
    @classmethod
    def from_constants(cls, elts: Optional[Any] = ...) -> Any: ...
    def itered(self) -> Any: ...
    def bool_value(self) -> Any: ...
    @abc.abstractmethod
    def pytype(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class LookupMixIn:
    def lookup(self, name: Any) -> Any: ...
    def ilookup(self, name: Any) -> Any: ...

class AssignName(mixins.NoChildrenMixin, LookupMixIn, mixins.ParentAssignTypeMixin, NodeNG):
    name: Any = ...
    def __init__(self, name: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class DelName(mixins.NoChildrenMixin, LookupMixIn, mixins.ParentAssignTypeMixin, NodeNG):
    name: Any = ...
    def __init__(self, name: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class Name(mixins.NoChildrenMixin, LookupMixIn, NodeNG):
    name: Any = ...
    def __init__(self, name: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class Arguments(mixins.AssignTypeMixin, NodeNG):
    varargannotation: Any = ...
    kwargannotation: Any = ...
    vararg: Any = ...
    kwarg: Any = ...
    args: Any = ...
    defaults: Any = ...
    kwonlyargs: Any = ...
    kw_defaults: Any = ...
    annotations: Any = ...
    kwonlyargs_annotations: Any = ...
    def __init__(self, vararg: Optional[Any] = ..., kwarg: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, args: Any, defaults: Any, kwonlyargs: Any, kw_defaults: Any, annotations: Any, kwonlyargs_annotations: Optional[Any] = ..., varargannotation: Optional[Any] = ..., kwargannotation: Optional[Any] = ...) -> None: ...
    def fromlineno(self) -> Any: ...
    def format_args(self) -> Any: ...
    def default_value(self, argname: Any) -> Any: ...
    def is_argument(self, name: Any) -> Any: ...
    def find_argname(self, argname: Any, rec: bool = ...) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class AssignAttr(mixins.ParentAssignTypeMixin, NodeNG):
    expr: Any = ...
    attrname: Any = ...
    def __init__(self, attrname: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, expr: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Assert(Statement):
    test: Any = ...
    fail: Any = ...
    def postinit(self, test: Optional[Any] = ..., fail: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Assign(mixins.AssignTypeMixin, Statement):
    targets: Any = ...
    value: Any = ...
    type_annotation: Any = ...
    def postinit(self, targets: Optional[Any] = ..., value: Optional[Any] = ..., type_annotation: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class AnnAssign(mixins.AssignTypeMixin, Statement):
    target: Any = ...
    annotation: Any = ...
    value: Any = ...
    simple: Any = ...
    def postinit(self, target: Any, annotation: Any, simple: Any, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class AugAssign(mixins.AssignTypeMixin, Statement):
    target: Any = ...
    value: Any = ...
    op: Any = ...
    def __init__(self, op: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, target: Optional[Any] = ..., value: Optional[Any] = ...) -> None: ...
    def type_errors(self, context: Optional[Any] = ...) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Repr(NodeNG):
    value: Any = ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...

class BinOp(NodeNG):
    left: Any = ...
    right: Any = ...
    op: Any = ...
    def __init__(self, op: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, left: Optional[Any] = ..., right: Optional[Any] = ...) -> None: ...
    def type_errors(self, context: Optional[Any] = ...) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def op_precedence(self) -> Any: ...
    def op_left_associative(self) -> Any: ...

class BoolOp(NodeNG):
    values: Any = ...
    op: Any = ...
    def __init__(self, op: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, values: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def op_precedence(self) -> Any: ...

class Break(mixins.NoChildrenMixin, Statement): ...

class Call(NodeNG):
    func: Optional[NodeNG] = ...
    args: Any = ...
    keywords: Any = ...
    def postinit(self, func: Optional[Any] = ..., args: Optional[Any] = ..., keywords: Optional[Any] = ...) -> None: ...
    @property
    def starargs(self) -> Any: ...
    @property
    def kwargs(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Compare(NodeNG):
    left: Any = ...
    ops: Any = ...
    def postinit(self, left: Optional[Any] = ..., ops: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def last_child(self) -> Any: ...

class Comprehension(NodeNG):
    target: Any = ...
    iter: Any = ...
    ifs: Any = ...
    is_async: Any = ...
    parent: Any = ...
    def __init__(self, parent: Optional[Any] = ...) -> None: ...
    def postinit(self, target: Optional[Any] = ..., iter: Optional[Any] = ..., ifs: Optional[Any] = ..., is_async: Optional[Any] = ...) -> None: ...
    optional_assign: bool = ...
    def assign_type(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Const(mixins.NoChildrenMixin, NodeNG, bases.Instance):
    value: Any = ...
    def __init__(self, value: Any, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def __getattr__(self, name: Any) -> Any: ...
    def getitem(self, index: Any, context: Optional[Any] = ...) -> Any: ...
    def has_dynamic_getattr(self) -> Any: ...
    def itered(self) -> Any: ...
    def pytype(self) -> Any: ...
    def bool_value(self) -> Any: ...

class Continue(mixins.NoChildrenMixin, Statement): ...

class Decorators(NodeNG):
    nodes: Any = ...
    def postinit(self, nodes: Any) -> None: ...
    def scope(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class DelAttr(mixins.ParentAssignTypeMixin, NodeNG):
    expr: Any = ...
    attrname: Any = ...
    def __init__(self, attrname: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, expr: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Delete(mixins.AssignTypeMixin, Statement):
    targets: Any = ...
    def postinit(self, targets: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Dict(NodeNG, bases.Instance):
    items: Any = ...
    def __init__(self, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, items: Any) -> None: ...
    @classmethod
    def from_constants(cls, items: Optional[Any] = ...) -> Any: ...
    def pytype(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def last_child(self) -> Any: ...
    def itered(self) -> Any: ...
    def getitem(self, index: Any, context: Optional[Any] = ...) -> Any: ...
    def bool_value(self) -> Any: ...

class Expr(Statement):
    value: Any = ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Ellipsis(mixins.NoChildrenMixin, NodeNG):
    def bool_value(self) -> Any: ...

class EmptyNode(mixins.NoChildrenMixin, NodeNG):
    object: Any = ...

class ExceptHandler(mixins.MultiLineBlockMixin, mixins.AssignTypeMixin, Statement):
    type: Any = ...
    name: Any = ...
    body: Any = ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def postinit(self, type: Optional[Any] = ..., name: Optional[Any] = ..., body: Optional[Any] = ...) -> None: ...
    def blockstart_tolineno(self) -> Any: ...
    def catch(self, exceptions: Any) -> Any: ...

class Exec(Statement):
    expr: Any = ...
    globals: Any = ...
    locals: Any = ...
    def postinit(self, expr: Optional[Any] = ..., globals: Optional[Any] = ..., locals: Optional[Any] = ...) -> None: ...

class ExtSlice(NodeNG):
    dims: Any = ...
    def postinit(self, dims: Optional[Any] = ...) -> None: ...

class For(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, mixins.AssignTypeMixin, Statement):
    target: Any = ...
    iter: Any = ...
    body: Any = ...
    orelse: Any = ...
    type_annotation: Any = ...
    def postinit(self, target: Optional[Any] = ..., iter: Optional[Any] = ..., body: Optional[Any] = ..., orelse: Optional[Any] = ..., type_annotation: Optional[Any] = ...) -> None: ...
    optional_assign: bool = ...
    def blockstart_tolineno(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class AsyncFor(For): ...

class Await(NodeNG):
    value: Any = ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class ImportFrom(mixins.NoChildrenMixin, mixins.ImportFromMixin, Statement):
    modname: Any = ...
    names: Any = ...
    level: Any = ...
    def __init__(self, fromname: Any, names: Any, level: int = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class Attribute(NodeNG):
    expr: Any = ...
    attrname: Any = ...
    def __init__(self, attrname: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, expr: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Global(mixins.NoChildrenMixin, Statement):
    names: Any = ...
    def __init__(self, names: Any, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class If(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
    test: Any = ...
    body: Any = ...
    orelse: Any = ...
    def postinit(self, test: Optional[Any] = ..., body: Optional[Any] = ..., orelse: Optional[Any] = ...) -> None: ...
    def blockstart_tolineno(self) -> Any: ...
    def block_range(self, lineno: Any) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def has_elif_block(self) -> Any: ...

class IfExp(NodeNG):
    test: Any = ...
    body: Any = ...
    orelse: Any = ...
    def postinit(self, test: Optional[Any] = ..., body: Optional[Any] = ..., orelse: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def op_left_associative(self) -> Any: ...

class Import(mixins.NoChildrenMixin, mixins.ImportFromMixin, Statement):
    names: Any = ...
    def __init__(self, names: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class Index(NodeNG):
    value: Any = ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Keyword(NodeNG):
    value: Any = ...
    arg: Any = ...
    def __init__(self, arg: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class List(_BaseContainer):
    ctx: Any = ...
    def __init__(self, ctx: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def pytype(self) -> Any: ...
    def getitem(self, index: Any, context: Optional[Any] = ...) -> Any: ...

class Nonlocal(mixins.NoChildrenMixin, Statement):
    names: Any = ...
    def __init__(self, names: Any, lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...

class Pass(mixins.NoChildrenMixin, Statement): ...

class Print(Statement):
    dest: Any = ...
    values: Any = ...
    nl: Any = ...
    def __init__(self, nl: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, dest: Optional[Any] = ..., values: Optional[Any] = ...) -> None: ...

class Raise(Statement):
    exc: Any = ...
    cause: Any = ...
    def postinit(self, exc: Optional[Any] = ..., cause: Optional[Any] = ...) -> None: ...
    def raises_not_implemented(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Return(Statement):
    value: Any = ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def is_tuple_return(self) -> Any: ...

class Set(_BaseContainer):
    def pytype(self) -> Any: ...

class Slice(NodeNG):
    lower: Any = ...
    upper: Any = ...
    step: Any = ...
    def postinit(self, lower: Optional[Any] = ..., upper: Optional[Any] = ..., step: Optional[Any] = ...) -> None: ...
    def pytype(self) -> Any: ...
    def igetattr(self, attrname: Any, context: Optional[Any] = ...) -> None: ...
    def getattr(self, attrname: Any, context: Optional[Any] = ...) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Starred(mixins.ParentAssignTypeMixin, NodeNG):
    value: Any = ...
    ctx: Any = ...
    def __init__(self, ctx: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Subscript(NodeNG):
    value: Any = ...
    slice: Any = ...
    ctx: Any = ...
    def __init__(self, ctx: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, value: Optional[Any] = ..., slice: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class TryExcept(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
    body: Any = ...
    handlers: Any = ...
    orelse: Any = ...
    def postinit(self, body: Optional[Any] = ..., handlers: Optional[Any] = ..., orelse: Optional[Any] = ...) -> None: ...
    def block_range(self, lineno: Any) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class TryFinally(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
    body: Any = ...
    finalbody: Any = ...
    def postinit(self, body: Optional[Any] = ..., finalbody: Optional[Any] = ...) -> None: ...
    def block_range(self, lineno: Any) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Tuple(_BaseContainer):
    ctx: Any = ...
    def __init__(self, ctx: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def pytype(self) -> Any: ...
    def getitem(self, index: Any, context: Optional[Any] = ...) -> Any: ...

class UnaryOp(NodeNG):
    operand: Any = ...
    op: Any = ...
    def __init__(self, op: Optional[Any] = ..., lineno: Optional[Any] = ..., col_offset: Optional[Any] = ..., parent: Optional[Any] = ...) -> None: ...
    def postinit(self, operand: Optional[Any] = ...) -> None: ...
    def type_errors(self, context: Optional[Any] = ...) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...
    def op_precedence(self) -> Any: ...

class While(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, Statement):
    test: Any = ...
    body: Any = ...
    orelse: Any = ...
    def postinit(self, test: Optional[Any] = ..., body: Optional[Any] = ..., orelse: Optional[Any] = ...) -> None: ...
    def blockstart_tolineno(self) -> Any: ...
    def block_range(self, lineno: Any) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class With(mixins.MultiLineBlockMixin, mixins.BlockRangeMixIn, mixins.AssignTypeMixin, Statement):
    items: Any = ...
    body: Any = ...
    type_annotation: Any = ...
    def postinit(self, items: Optional[Any] = ..., body: Optional[Any] = ..., type_annotation: Optional[Any] = ...) -> None: ...
    def blockstart_tolineno(self) -> Any: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class AsyncWith(With): ...

class Yield(NodeNG):
    value: Any = ...
    def postinit(self, value: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class YieldFrom(Yield): ...
class DictUnpack(mixins.NoChildrenMixin, NodeNG): ...

class FormattedValue(NodeNG):
    value: Any = ...
    conversion: Any = ...
    format_spec: Any = ...
    def postinit(self, value: Any, conversion: Optional[Any] = ..., format_spec: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class JoinedStr(NodeNG):
    values: Any = ...
    def postinit(self, values: Optional[Any] = ...) -> None: ...
    def get_children(self) -> Iterator[NodeNG]: ...

class Unknown(mixins.AssignTypeMixin, NodeNG):
    name: str = ...
    def qname(self) -> Any: ...
    def infer(self, context: Optional[Any] = ..., **kwargs: Any) -> None: ...

CONST_CLS: Any

def const_factory(value: Any) -> Any: ...
def is_from_decorator(node: Any) -> Any: ...
